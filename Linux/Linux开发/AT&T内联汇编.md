# 内联汇编

```
__asm__("asm statements" : outputs : inputs : registers-modified);
```

## asm statements

通常称为指令部，其格式和在汇编语言中使用的格式基本相同。


在将芘主语句嵌入到C代码中时，操作数如何与C代码中的变量结合是个很大的问题：程序员提供具体的指令，而对寄存器的使用则只需给出样板和约束条件就可以了，具体如何将寄存器与变量结合起来完全由GCC和GAS来负责。

在GCC内联汇编语句的指令部中，加上前缀`%`的数字（如%0，%1）表示的就是需要使用寄存器的样板操作数。指令部中使用了几个样板操作数，就表明有几个变量需要与寄存器相结合。由于样板操作数也使用`%`作为前缀，因此在涉及到具体的寄存器时，寄存器名前面应该加上两个`%`，以免产生混淆。

## outputs

紧跟在指令部后的是输出部，是规定输出变量如何与样板操作数进行结合的条件，每个条件称为一个`约束`，必要时可以包含多个约束，相互之间用逗号分隔开就可以了。每个输出约束都以`=`号开始，然后紧跟一个对操作数类型进行说明的字后，最后是如何与变量相结合的约束。凡是与输出部中说明的操作数相结合的寄存器或操作数本身，在执行完嵌入的汇编代码后均不保留执行之前的内容，这是GCC在调试寄存器时所使用的依据。




## inputs

输出部后面是输入部，输入约束的格式和输出约束相似，但不带`=`号。如果一个输入约束要求使用寄存器，则GCC在预处理时就会为之分配一个寄存器，并插入必要的指令将操作数装入该寄存器。与输入部中说明的操作数结合的寄存器或操作数本身，在执行完嵌入的汇编代码后也不保留执行之前的内容。


## registers-modified

有时在进行某些操作时，除了要用到进行数据输入和输出的寄存器外，还要使用多个寄存器来保存中间计算结果，这样就难免会破坏原有寄存器的内容。在GCC内联汇编格式中的最后一个部分中，可以对将产生副作用的寄存器进行说明，以便GCC能够采用相应的措施。


## 例子

```
int main()
{
    int a = 10, b = 0;
    __asm__ __volatile__("movl %1, %%eax;/n/t"      // 这个%1是输入操作数
                            "movl %%eax, %0;"       // 这个%0是输出操作数
                            :"=r"(b)                // 这里是output处，其实是相当于把%0换成b，改成 movl %eax, b
                            :"r"(a)                 // 这里是input处，其实是把%1换成a，改成 movl a, %eax
                            :"%eax");               // 由于上面的指令用到了eax寄存器，可能会影响到原有的值，在这里标示出来，让gcc编译器知道，好做后续准备。内联汇编语句的最后一个部分告诉GCC它将改变寄存器eax中的值，GCC在处理时不应使用该寄存器来存储任何其它的值。
    printf("Result: %d, %d\n", a, b);
}
```

https://www.cnblogs.com/hdk1993/p/4820353.html

