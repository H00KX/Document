## 应用层ZwCreateFile代码

```asm
mov r10,rcx
mov eax,55
test byte ptr ds:[7FFE0308],1
jne ntdll.7FFE9EB8F035
syscall 
ret 
int 2E
ret 
```

说明SSDT序号为0x55，使用`syscall`进入内核

### syscall:

SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the `IA32_LSTAR MSR` (after saving the address of the instruction following SYSCALL into RCX)

SYSCALL also saves RFLAGS into R11 and then masks RFLAGS using the IA32_FMASK MSR **(MSR address C0000084H)**; specifically, the processor clears in RFLAGS every bit corresponding to a bit that is set in the IA32_FMASK MSR.

SYSCALL loads the `CS` and `SS` selectors with values derived from `bits 47:32 of the IA32_STAR MSR`.

The SYSCALL instruction does **not** save the stack pointer (RSP). If the OS system-call handler will change the stack pointer, it is the responsibility of software to save the previous value of the stack pointer. This might be done prior to executing SYSCALL, with software restoring the stack pointer with the instruction following SYSCALL (which will be executed after `SYSRET`). Alternatively, the OS system-call handler may save the stack pointer and restore it before executing SYSRET.

**Instruction ordering**. Instructions following a SYSCALL may be fetched from memory before earlier instructions complete execution, but they will not execute (even speculatively) until all instructions prior to the SYSCALL have completed execution (the later instructions may execute before data stored by the earlier instructions have become globally visible).

- IA32_STAR（0xC0000081）：Ring 0和Ring 3段基址，以及SYSCALL的EIP。在较低的32位中存储的是SYSCALL的EIP，在第32-47位存储内核段基址，在第48-63为存储用户段基址。
- IA32_CSTAR（0xC0000083）：兼容模式下，SYSCALL的内核RIP相对寻址。
- IA32_LSTAR（0xC0000082）：长模式（Long Mode，即64位）下，SYSCALL的内核RIP相对寻址。



---

`KiIntSystemCall`和`KiFastSystemCall`这两个函数都在用户空间的动态链接库`ntdll.dll`中，而`ntdll.dll`是个基本的“系统dll”，实际上在系统的初始化阶段就会被装入，要不然什么进程也运行不了。从那以后，这个Dll就一直驻留在内存中；不管在什么进程中，其出现的位置都是相同的。内核在初始化阶段根据处理器的`CPUID`判断其是否支持快速系统调用，而从`ntdll.dll`的映像中找到`KiFastSystemCall`或`KiIntSystemCall`的地址，将其写入用户空间的地址`0x7ffe0330(不变)`。其实CPU写入的是系统空间的地址`0xffdf0300(不变)`，**但是系统空间`0xffdf0000`的地方与用户空间`0x7ffe0000`的地方就好像是一条隧道的两端，两块64KB的虚存区间都映射到同一块物理内存。**
